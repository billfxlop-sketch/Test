#!/bin/bash

# MAUT PANEL PRO EDITION - BACKUP & RESTORE MANAGER
# Owner: @maut_coder
# Powered by MAUT CODER

# Configuration
PANEL_DIR="/opt/maut-panel"
CONFIG_DIR="$PANEL_DIR/config"
SCRIPT_DIR="$PANEL_DIR/scripts"
BACKUP_DIR="$PANEL_DIR/backup"
LOG_DIR="/var/log/maut-panel"
USER_DB="$CONFIG_DIR/maut-users.db"
XRAY_CONFIG="/usr/local/etc/xray/config.json"
THEME_FILE="$CONFIG_DIR/maut-theme.conf"

# Load theme
load_theme() {
    if [[ -f "$THEME_FILE" ]]; then
        source "$THEME_FILE"
    else
        COLOR_PRIMARY='\033[0;31m'
        COLOR_SECONDARY='\033[0;33m'
        COLOR_ACCENT='\033[0;36m'
        COLOR_SUCCESS='\033[0;32m'
        COLOR_WARNING='\033[1;33m'
        COLOR_ERROR='\033[0;31m'
        COLOR_INFO='\033[0;34m'
        COLOR_RESET='\033[0m'
    fi
}

# Logging
log_action() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - BACKUP: $1" >> "$LOG_DIR/maut-actions.log"
}

# Create backup
create_backup() {
    echo -e "${COLOR_INFO}Creating Backup${COLOR_RESET}"
    echo ""
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="maut_backup_$timestamp"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    mkdir -p "$backup_path"
    
    echo -e "${COLOR_INFO}Backing up panel configuration...${COLOR_RESET}"
    
    # Backup configuration files
    cp -r "$CONFIG_DIR" "$backup_path/" 2>/dev/null
    cp -r "$SCRIPT_DIR" "$backup_path/" 2>/dev/null
    
    # Backup Xray configuration
    if [[ -f "$XRAY_CONFIG" ]]; then
        cp "$XRAY_CONFIG" "$backup_path/" 2>/dev/null
    fi
    
    # Backup user database
    if [[ -f "$USER_DB" ]]; then
        cp "$USER_DB" "$backup_path/" 2>/dev/null
    fi
    
    # Backup SSL certificates
    if [[ -d "/etc/maut/ssl" ]]; then
        cp -r "/etc/maut/ssl" "$backup_path/" 2>/dev/null
    fi
    
    # Backup Nginx configuration if exists
    if [[ -f "/etc/nginx/conf.d/maut-websocket.conf" ]]; then
        mkdir -p "$backup_path/nginx"
        cp /etc/nginx/conf.d/maut-websocket.conf "$backup_path/nginx/" 2>/dev/null
    fi
    
    # Create backup info file
    cat > "$backup_path/backup.info" << EOF
MAUT PANEL PRO BACKUP
Created: $(date)
Version: 2.1
Backup ID: $backup_name
Contents:
- Panel configuration
- User database
- Xray configuration
- SSL certificates
- Script files
EOF

    # Create compressed archive
    echo -e "${COLOR_INFO}Creating compressed archive...${COLOR_RESET}"
    cd "$BACKUP_DIR" && tar -czf "$backup_name.tar.gz" "$backup_name"
    
    if [ $? -eq 0 ]; then
        # Remove temporary directory
        rm -rf "$backup_path"
        
        local backup_file="$BACKUP_DIR/$backup_name.tar.gz"
        local backup_size=$(du -h "$backup_file" | cut -f1)
        
        echo -e "${COLOR_SUCCESS}Backup created successfully!${COLOR_RESET}"
        echo -e "${COLOR_INFO}Backup file: ${COLOR_SUCCESS}$backup_name.tar.gz${COLOR_RESET}"
        echo -e "${COLOR_INFO}Size: ${COLOR_SUCCESS}$backup_size${COLOR_RESET}"
        echo -e "${COLOR_INFO}Location: ${COLOR_SUCCESS}$BACKUP_DIR${COLOR_RESET}"
        
        log_action "Created backup: $backup_name.tar.gz ($backup_size)"
    else
        echo -e "${COLOR_ERROR}Failed to create compressed backup${COLOR_RESET}"
        return 1
    fi
}

# List backups
list_backups() {
    echo -e "${COLOR_INFO}Available Backups${COLOR_RESET}"
    echo ""
    
    if [[ ! -d "$BACKUP_DIR" ]]; then
        echo -e "${COLOR_WARNING}Backup directory does not exist${COLOR_RESET}"
        return
    fi
    
    local backups=($(ls -t "$BACKUP_DIR"/*.tar.gz 2>/dev/null))
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        echo -e "${COLOR_WARNING}No backup files found${COLOR_RESET}"
        return
    fi
    
    echo -e "${COLOR_PRIMARY}Backup File | Size | Date${COLOR_RESET}"
    echo "─────────────┼───────┼─────────────────"
    
    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local size=$(du -h "$backup" | cut -f1)
        local date=$(stat -c %y "$backup" | cut -d' ' -f1)
        echo -e "$filename | $size | $date"
    done
    
    echo ""
    echo -e "${COLOR_INFO}Total backups: ${#backups[@]}${COLOR_RESET}"
    
    # Show disk usage
    local total_size=$(du -sh "$BACKUP_DIR" | cut -f1)
    echo -e "${COLOR_INFO}Backup directory size: $total_size${COLOR_RESET}"
}

# Restore backup
restore_backup() {
    echo -e "${COLOR_INFO}Restore Backup${COLOR_RESET}"
    echo ""
    
    local backups=($(ls -t "$BACKUP_DIR"/*.tar.gz 2>/dev/null))
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        echo -e "${COLOR_ERROR}No backup files found${COLOR_RESET}"
        return 1
    fi
    
    echo -e "${COLOR_INFO}Available backups:${COLOR_RESET}"
    local i=1
    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local size=$(du -h "$backup" | cut -f1)
        local date=$(stat -c %y "$backup" | cut -d' ' -f1-2)
        echo "$i. $filename ($size) - $date"
        ((i++))
    done
    
    echo ""
    read -p "Select backup to restore (1-${#backups[@]}): " choice
    
    if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#backups[@]} ]; then
        echo -e "${COLOR_ERROR}Invalid selection${COLOR_RESET}"
        return 1
    fi
    
    local selected_backup="${backups[$((choice-1))]}"
    local backup_name=$(basename "$selected_backup" .tar.gz)
    local temp_dir="$BACKUP_DIR/restore_temp"
    
    echo -e "${COLOR_WARNING}This will restore backup: $backup_name${COLOR_RESET}"
    echo -e "${COLOR_WARNING}Current configuration will be overwritten!${COLOR_RESET}"
    read -p "Are you sure you want to continue? (y/N): " confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Restore cancelled"
        return
    fi
    
    # Create temporary directory for extraction
    mkdir -p "$temp_dir"
    
    echo -e "${COLOR_INFO}Extracting backup...${COLOR_RESET}"
    tar -xzf "$selected_backup" -C "$temp_dir"
    
    if [ $? -ne 0 ]; then
        echo -e "${COLOR_ERROR}Failed to extract backup${COLOR_RESET}"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Stop services before restore
    echo -e "${COLOR_INFO}Stopping services...${COLOR_RESET}"
    systemctl stop xray 2>/dev/null
    
    # Restore files
    echo -e "${COLOR_INFO}Restoring configuration...${COLOR_RESET}"
    
    # Restore panel configuration
    if [[ -d "$temp_dir/$backup_name/config" ]]; then
        cp -r "$temp_dir/$backup_name/config"/* "$CONFIG_DIR/" 2>/dev/null
    fi
    
    # Restore scripts
    if [[ -d "$temp_dir/$backup_name/scripts" ]]; then
        cp -r "$temp_dir/$backup_name/scripts"/* "$SCRIPT_DIR/" 2>/dev/null
        chmod +x "$SCRIPT_DIR"/* 2>/dev/null
    fi
    
    # Restore Xray configuration
    if [[ -f "$temp_dir/$backup_name/config.json" ]]; then
        cp "$temp_dir/$backup_name/config.json" "$XRAY_CONFIG" 2>/dev/null
    fi
    
    # Restore user database
    if [[ -f "$temp_dir/$backup_name/maut-users.db" ]]; then
        cp "$temp_dir/$backup_name/maut-users.db" "$USER_DB" 2>/dev/null
    fi
    
    # Restore SSL certificates
    if [[ -d "$temp_dir/$backup_name/ssl" ]]; then
        cp -r "$temp_dir/$backup_name/ssl"/* "/etc/maut/ssl/" 2>/dev/null
    fi
    
    # Restore Nginx configuration
    if [[ -d "$temp_dir/$backup_name/nginx" ]]; then
        cp "$temp_dir/$backup_name/nginx"/* "/etc/nginx/conf.d/" 2>/dev/null
    fi
    
    # Cleanup temporary directory
    rm -rf "$temp_dir"
    
    # Restart services
    echo -e "${COLOR_INFO}Restarting services...${COLOR_RESET}"
    systemctl start xray 2>/dev/null
    systemctl reload nginx 2>/dev/null
    
    echo -e "${COLOR_SUCCESS}Backup restored successfully!${COLOR_RESET}"
    log_action "Restored backup: $backup_name"
    
    # Show restore summary
    echo ""
    echo -e "${COLOR_SUCCESS}Restore Summary:${COLOR_RESET}"
    echo -e "✓ Panel configuration"
    echo -e "✓ User database"
    echo -e "✓ Xray configuration"
    echo -e "✓ SSL certificates"
    echo -e "✓ Service configurations"
}

# Auto backup (for cron jobs)
auto_backup() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="maut_auto_backup_$timestamp"
    local backup_path="$BACKUP_DIR/$backup_name.tar.gz"
    
    # Create backup
    mkdir -p "$BACKUP_DIR/temp"
    cp -r "$CONFIG_DIR" "$BACKUP_DIR/temp/" 2>/dev/null
    cp "$XRAY_CONFIG" "$BACKUP_DIR/temp/" 2>/dev/null
    cp "$USER_DB" "$BACKUP_DIR/temp/" 2>/dev/null
    
    cd "$BACKUP_DIR" && tar -czf "$backup_path" "temp" && rm -rf "temp"
    
    if [ $? -eq 0 ]; then
        # Keep only last 7 auto backups
        ls -t "$BACKUP_DIR"/maut_auto_backup_*.tar.gz 2>/dev/null | tail -n +8 | xargs -r rm
        
        log_action "Auto backup created: $backup_name.tar.gz"
    else
        log_action "Auto backup failed"
    fi
}

# Download backup
download_backup() {
    echo -e "${COLOR_INFO}Download Backup${COLOR_RESET}"
    echo ""
    
    local backups=($(ls -t "$BACKUP_DIR"/*.tar.gz 2>/dev/null))
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        echo -e "${COLOR_ERROR}No backup files found${COLOR_RESET}"
        return 1
    fi
    
    echo -e "${COLOR_INFO}Available backups:${COLOR_RESET}"
    local i=1
    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local size=$(du -h "$backup" | cut -f1)
        echo "$i. $filename ($size)"
        ((i++))
    done
    
    echo ""
    read -p "Select backup to download (1-${#backups[@]}): " choice
    
    if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#backups[@]} ]; then
        echo -e "${COLOR_ERROR}Invalid selection${COLOR_RESET}"
        return 1
    fi
    
    local selected_backup="${backups[$((choice-1))]}"
    local filename=$(basename "$selected_backup")
    
    echo -e "${COLOR_INFO}Backup file: $filename${COLOR_RESET}"
    echo -e "${COLOR_INFO}You can download the backup from:${COLOR_RESET}"
    echo -e "${COLOR_SUCCESS}$selected_backup${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_INFO}To download via SCP:${COLOR_RESET}"
    echo -e "scp root@$(curl -s ipv4.icanhazip.com):$selected_backup ./"
    echo ""
    echo -e "${COLOR_INFO}Or via HTTP (if web server is configured):${COLOR_RESET}"
    echo -e "http://your-server-ip/backups/$filename"
    
    log_action "Downloaded backup: $filename"
}

# Upload backup
upload_backup() {
    echo -e "${COLOR_INFO}Upload Backup${COLOR_RESET}"
    echo ""
    
    echo -e "${COLOR_INFO}Please upload your backup file to:${COLOR_RESET}"
    echo -e "${COLOR_SUCCESS}$BACKUP_DIR/${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_INFO}You can use SCP to upload:${COLOR_RESET}"
    echo -e "scp your_backup.tar.gz root@$(curl -s ipv4.icanhazip.com):$BACKUP_DIR/"
    echo ""
    echo -e "${COLOR_INFO}After uploading, use the restore function to restore the backup.${COLOR_RESET}"
    
    read -p "Press Enter to continue after uploading..."
}

# Backup settings
backup_settings() {
    echo -e "${COLOR_INFO}Backup Settings${COLOR_RESET}"
    echo ""
    
    # Show current backup directory status
    local total_backups=$(ls "$BACKUP_DIR"/*.tar.gz 2>/dev/null | wc -l)
    local total_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
    
    echo -e "${COLOR_SUCCESS}Current Status:${COLOR_RESET}"
    echo -e "Backup directory: $BACKUP_DIR"
    echo -e "Total backups: $total_backups"
    echo -e "Total size: $total_size"
    echo ""
    
    # Show cron job status
    echo -e "${COLOR_SUCCESS}Auto Backup Schedule:${COLOR_RESET}"
    if crontab -l 2>/dev/null | grep -q "maut-backup auto"; then
        echo -e "${COLOR_SUCCESS}✓ Auto backup is enabled${COLOR_RESET}"
        crontab -l | grep "maut-backup auto"
    else
        echo -e "${COLOR_WARNING}⚠ Auto backup is disabled${COLOR_RESET}"
    fi
    
    echo ""
    echo "1. Enable auto backup (daily at 2 AM)"
    echo "2. Disable auto backup"
    echo "3. Change backup retention (keep last N backups)"
    echo "4. Back to menu"
    
    read -p "Enter your choice: " choice
    
    case $choice in
        1)
            (crontab -l 2>/dev/null; echo "0 2 * * * $SCRIPT_DIR/maut-backup auto") | crontab -
            echo -e "${COLOR_SUCCESS}Auto backup enabled (daily at 2 AM)${COLOR_RESET}"
            log_action "Enabled auto backup"
            ;;
        2)
            crontab -l 2>/dev/null | grep -v "maut-backup auto" | crontab -
            echo -e "${COLOR_SUCCESS}Auto backup disabled${COLOR_RESET}"
            log_action "Disabled auto backup"
            ;;
        3)
            read -p "Enter number of backups to keep (default: 7): " retention
            retention=${retention:-7}
            echo -e "${COLOR_INFO}Backup retention set to $retention backups${COLOR_RESET}"
            # This would be implemented in the auto backup function
            ;;
        4)
            return
            ;;
        *)
            echo -e "${COLOR_ERROR}Invalid choice${COLOR_RESET}"
            ;;
    esac
}

# Cleanup old backups
cleanup_backups() {
    echo -e "${COLOR_INFO}Cleanup Old Backups${COLOR_RESET}"
    echo ""
    
    read -p "Enter number of backups to keep (default: 10): " keep_count
    keep_count=${keep_count:-10}
    
    local backups=($(ls -t "$BACKUP_DIR"/*.tar.gz 2>/dev/null))
    local total_count=${#backups[@]}
    
    if [[ $total_count -le $keep_count ]]; then
        echo -e "${COLOR_INFO}No cleanup needed. Total backups: $total_count${COLOR_RESET}"
        return
    fi
    
    local delete_count=$((total_count - keep_count))
    echo -e "${COLOR_WARNING}This will delete $delete_count old backup(s)${COLOR_RESET}"
    read -p "Are you sure? (y/N): " confirm
    
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        ls -t "$BACKUP_DIR"/*.tar.gz | tail -n $delete_count | xargs -r rm
        echo -e "${COLOR_SUCCESS}Cleanup completed. Kept $keep_count latest backups.${COLOR_RESET}"
        log_action "Cleaned up backups, kept $keep_count"
    else
        echo "Cleanup cancelled"
    fi
}

# Backup menu
show_backup_menu() {
    clear
    echo -e "${COLOR_PRIMARY}"
    echo " ╔══════════════════════════════════════╗"
    echo " ║         BACKUP & RESTORE MANAGER    ║"
    echo " ║           MAUT PANEL PRO            ║"
    echo " ╚══════════════════════════════════════╝"
    echo -e "${COLOR_RESET}"
    echo -e "${COLOR_INFO}Manage panel backups and restoration${COLOR_RESET}"
    echo "════════════════════════════════════════"
    echo ""
    
    # Show backup status
    local backup_count=$(ls "$BACKUP_DIR"/*.tar.gz 2>/dev/null | wc -l)
    if [[ $backup_count -gt 0 ]]; then
        local latest_backup=$(ls -t "$BACKUP_DIR"/*.tar.gz | head -1)
        local latest_size=$(du -h "$latest_backup" | cut -f1)
        local latest_date=$(stat -c %y "$latest_backup" | cut -d' ' -f1)
        echo -e "${COLOR_SUCCESS}Latest backup: $(basename "$latest_backup") ($latest_size) - $latest_date${COLOR_RESET}"
    else
        echo -e "${COLOR_WARNING}No backups available${COLOR_RESET}"
    fi
    echo ""
    
    echo -e "${COLOR_PRIMARY}BACKUP MENU:${COLOR_RESET}"
    echo -e "${COLOR_SUCCESS}01${COLOR_RESET} Create Backup"
    echo -e "${COLOR_SUCCESS}02${COLOR_RESET} List Backups"
    echo -e "${COLOR_SUCCESS}03${COLOR_RESET} Restore Backup"
    echo -e "${COLOR_SUCCESS}04${COLOR_RESET} Download Backup"
    echo -e "${COLOR_SUCCESS}05${COLOR_RESET} Upload Backup"
    echo -e "${COLOR_SUCCESS}06${COLOR_RESET} Backup Settings"
    echo -e "${COLOR_SUCCESS}07${COLOR_RESET} Cleanup Old Backups"
    echo -e "${COLOR_SUCCESS}08${COLOR_RESET} Back to Main Menu"
    echo ""
}

# Main backup function
main() {
    load_theme
    
    # Create backup directory if it doesn't exist
    mkdir -p "$BACKUP_DIR"
    
    # Handle auto backup if argument passed
    if [[ "$1" == "auto" ]]; then
        auto_backup
        return
    fi
    
    while true; do
        show_backup_menu
        
        read -p "Enter your choice: " choice
        echo ""
        
        case $choice in
            01) create_backup ;;
            02) list_backups ;;
            03) restore_backup ;;
            04) download_backup ;;
            05) upload_backup ;;
            06) backup_settings ;;
            07) cleanup_backups ;;
            08) 
                log_action "Exited Backup Manager"
                break 
                ;;
            *) 
                echo -e "${COLOR_ERROR}Invalid choice! Please try again.${COLOR_RESET}"
                ;;
        esac
        
        echo ""
        read -p "Press Enter to continue..."
    done
}

# Start main function
main "$@"